<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Suicide Squaf Dynasty Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0f172a;
      --bg-alt: #020617;
      --card: #020817;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --border: #1e293b;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
      --radius-lg: 16px;
      --radius-md: 10px;
      --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.9);
      --transition: 0.18s ease-out;
      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: var(--font-sans);
      background: radial-gradient(circle at top, #1d283a 0, #020617 45%, #000 100%);
      color: var(--text);
    }

    h1, h2, h3 {
      margin: 0;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    h1 {
      font-size: 1.9rem;
    }

    h2 {
      font-size: 1.2rem;
      margin-bottom: 0.75rem;
    }

    p {
      margin: 0;
    }

    .app-shell {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      margin-bottom: 24px;
      gap: 16px;
    }

    .header-title span.badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.1);
      color: var(--muted);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 6px;
    }

    .header-title span.badge::before {
      content: "";
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 6px rgba(34, 197, 94, 0.28);
    }

    .header-subtitle {
      margin-top: 4px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .header-meta {
      text-align: right;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .header-meta strong {
      color: var(--accent);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.2);
      margin-top: 6px;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: 18px;
      margin-bottom: 20px;
    }

    @media (max-width: 960px) {
      body { padding: 16px; }
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
      .header { flex-direction: column; align-items: flex-start; }
      .header-meta { text-align: left; }
    }

    .card {
      background: radial-gradient(
          circle at top left,
          rgba(56, 189, 248, 0.09),
          transparent 55%
        ),
        var(--card);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-soft);
      padding: 16px 18px 18px;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px solid rgba(56, 189, 248, 0.18);
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition);
    }

    .card:hover::before {
      opacity: 1;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 12px;
    }

    .card-header small {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .card-section-title {
      font-size: 0.78rem;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.16em;
      margin-bottom: 6px;
    }

    .card-body {
      font-size: 0.9rem;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
    }

    label {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    select, input[type="number"], input[type="text"] {
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      padding: 7px 9px;
      font-size: 0.9rem;
      outline: none;
      transition: border-color var(--transition), box-shadow var(--transition),
        background var(--transition), transform 0.06s ease-out;
    }

    select:focus,
    input[type="number"]:focus,
    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
      background: #020617;
      transform: translateY(-1px);
    }

    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
    }

    .btn-row {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 8px;
    }

    button {
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.85rem;
      padding: 7px 13px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #0b1220;
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.35);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
        filter 0.08s ease-out, background 0.2s ease-out;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 16px 35px rgba(37, 99, 235, 0.45);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 6px 15px rgba(15, 23, 42, 0.8);
      filter: brightness(0.98);
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.95);
      color: var(--muted);
      border-color: rgba(148, 163, 184, 0.5);
      box-shadow: none;
      text-transform: none;
      letter-spacing: 0.02em;
    }

    button.secondary:hover {
      background: rgba(15, 23, 42, 1);
      border-color: rgba(148, 163, 184, 0.9);
    }

    .btn-small {
      font-size: 0.7rem;
      padding: 4px 8px;
      text-transform: none;
      letter-spacing: 0.02em;
    }

    .pill-info {
      margin-top: 6px;
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill-info span {
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .pill-info strong {
      color: var(--accent);
    }

    .spread-chip {
      font-weight: 500;
    }

    .table-wrapper {
      margin-top: 12px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      overflow: hidden;
      background: rgba(15, 23, 42, 0.9);
      max-height: 360px;
      overflow-y: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    thead {
      position: sticky;
      top: 0;
      background: linear-gradient(to right, #020617, #020617);
      z-index: 1;
    }

    th, td {
      padding: 6px 8px;
      border-bottom: 1px solid rgba(30, 64, 175, 0.5);
      white-space: nowrap;
      text-align: left;
    }

    th {
      text-transform: uppercase;
      letter-spacing: 0.09em;
      font-size: 0.72rem;
      color: var(--muted);
    }

    tbody tr:nth-child(even) {
      background: rgba(15, 23, 42, 0.85);
    }

    tbody tr:hover {
      background: rgba(15, 23, 42, 1);
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.72rem;
      background: rgba(22, 163, 74, 0.18);
      color: #4ade80;
      border: 1px solid rgba(34, 197, 94, 0.45);
    }

    .tag.loss {
      background: rgba(239, 68, 68, 0.18);
      color: #fb7185;
      border-color: rgba(248, 113, 113, 0.5);
    }

    .muted {
      color: var(--muted);
      font-size: 0.78rem;
    }

    .small {
      font-size: 0.75rem;
    }

    .badge-soft {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.17);
      color: var(--muted);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .text-right { text-align: right; }
    .text-center { text-align: center; }

    .elo-up {
      color: #4ade80;
    }

    .elo-down {
      color: #fb7185;
    }

    .section {
      margin-top: 14px;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .section-header p {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .section-header h3 {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .matrix-note {
      font-size: 0.7rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .danger {
      color: var(--danger);
    }

    .chip-mini {
      display: inline-flex;
      align-items: center;
      padding: 1px 6px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 0.68rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
      gap: 4px;
    }

    .chip-mini-dot {
      width: 5px;
      height: 5px;
      border-radius: 999px;
      background: var(--accent);
    }

    .players-table {
      max-height: 320px;
    }

    .link-like {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
      color: var(--muted);
      font-size: 0.78rem;
    }

    .admin-indicator {
      margin-top: 4px;
      font-size: 0.75rem;
    }

    .admin-indicator span {
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(34, 197, 94, 0.15);
      border: 1px solid rgba(34, 197, 94, 0.4);
      color: #4ade80;
    }
  </style>
</head>
<body>
<div class="app-shell">
  <header class="header">
    <div class="header-title">
      <span class="badge">Suicide Squaf · Dynasty Tracker</span>
      <h1>Suicide Squaf Dynasty Tracker</h1>
      <p class="header-subtitle">
        Track every user game, Elo movement, spreads, and head-to-head records for your CFB26 dynasty.
      </p>
    </div>
    <div class="header-meta">
      <div><strong>K = 30</strong> Elo, starting at <strong>1500</strong></div>
      <div class="pill">
        <div class="pill-dot"></div>
        <span>All data saved in this browser (localStorage)</span>
      </div>
    </div>
  </header>

  <main>
    <!-- Top layout: Game entry (left) + Current Elo (right) -->
    <section class="layout">
      <!-- Left: Game Entry -->
      <div class="card">
        <div class="card-header">
          <div>
            <div class="card-section-title">Game Entry</div>
            <h2>Record a Result</h2>
          </div>
          <small id="game-count-label">0 games recorded</small>
        </div>

        <div class="card-body">
          <form id="gameForm">
            <div class="grid-2">
              <div class="field">
                <label for="player1">Player 1</label>
                <select id="player1" required></select>
              </div>
              <div class="field">
                <label for="score1">Score 1</label>
                <input type="number" id="score1" min="0" step="1" required />
              </div>
            </div>

            <div class="grid-2">
              <div class="field">
                <label for="player2">Player 2</label>
                <select id="player2" required></select>
              </div>
              <div class="field">
                <label for="score2">Score 2</label>
                <input type="number" id="score2" min="0" step="1" required />
              </div>
            </div>

            <!-- Line + preview lives here -->
            <div class="pill-info" id="preGameInfo">
              <span>Pick two players to see the line and Elo impact for this matchup.</span>
            </div>

            <div class="btn-row">
              <button type="submit" id="saveGameBtn">
                Save Game
              </button>
            </div>
          </form>

          <p class="matrix-note">
            Elo: win = 1, loss = 0, tie = 0.5. Margin of victory increases the Elo swing.
          </p>
        </div>
      </div>

      <!-- Right: Current Elo table -->
      <div class="card">
        <div class="card-header">
          <div>
            <div class="card-section-title">Standings</div>
            <h2>Current Elo</h2>
          </div>
          <small id="player-count-label">0 players</small>
        </div>
        <div class="card-body">
          <div class="table-wrapper players-table">
            <table id="playersTable">
              <thead>
              <tr>
                <th>Player</th>
                <th class="text-right">Elo</th>
                <th class="text-right">Games</th>
                <th class="text-right">W–L</th>
              </tr>
              </thead>
              <tbody>
              <!-- Filled by JS -->
              </tbody>
            </table>
          </div>
          <p class="matrix-note">
            Sorted by Elo, then head-to-head among tied players, then alphabetically.
          </p>
        </div>
      </div>
    </section>

    <!-- Games table -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-section-title">History</div>
          <h2>All Games &amp; Elo Movement</h2>
        </div>
        <small class="muted">
          Newest games at the top · <span id="last-updated-label"></span>
        </small>
      </div>
      <div class="card-body">
        <div class="table-wrapper">
          <table id="gamesTable">
            <thead>
            <tr>
              <th>Date</th>
              <th>Matchup</th>
              <th>Score</th>
              <th>Result</th>
              <th>Player 1 Elo</th>
              <th>Player 2 Elo</th>
              <th class="text-right">Admin</th>
            </tr>
            </thead>
            <tbody>
            <!-- Filled by JS -->
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- Head to Head matrix -->
    <section class="card section">
      <div class="card-header">
        <div>
          <div class="card-section-title">Analytics</div>
          <h2>Head-to-Head Records</h2>
        </div>
        <small class="muted">
          Players listed alphabetically · Cell = row player’s record vs column player (W–L)
        </small>
      </div>
      <div class="card-body">
        <div class="table-wrapper" id="h2hWrapper">
          <table id="h2hTable">
            <thead>
            <!-- Filled by JS -->
            </thead>
            <tbody>
            <!-- Filled by JS -->
            </tbody>
          </table>
        </div>
        <p class="matrix-note">
          Ties aren’t counted in W–L; you can extend the logic to track ties if your league uses them.
        </p>
      </div>
    </section>

    <!-- Bottom: Manage Players & Admin -->
    <section class="card section">
      <div class="card-header">
        <div>
          <div class="card-section-title">Players &amp; Admin</div>
          <h2>Manage Players</h2>
        </div>
        <div style="text-align:right;">
          <button id="adminLoginBtn" class="secondary btn-small" type="button">
            Admin Login
          </button>
          <div class="admin-indicator" id="adminStatus"></div>
        </div>
      </div>
      <div class="card-body">
        <div class="grid-2">
          <div class="field">
            <label for="newPlayerName">Add player</label>
            <input type="text" id="newPlayerName" placeholder="e.g. Roy, Brad, Kalin" />
          </div>
          <div class="field" style="align-self:flex-end;">
            <button id="addPlayerBtn" type="button">
              + Add Player
            </button>
          </div>
        </div>
        <p class="matrix-note">
          Press <strong>Enter</strong> in the name box or click “Add Player”.
        </p>

        <div class="section">
          <div class="section-header">
            <h3>Danger Zone</h3>
            <p class="danger">Admin only – wipes all players &amp; games from this browser.</p>
          </div>
          <button class="secondary btn-small danger" type="button" id="resetDataBtn">
            Reset All Data
          </button>
        </div>
      </div>
    </section>
  </main>
</div>

<script>
  // ======= CONFIG =======
  const K_FACTOR = 30;
  const START_ELO = 1500;
  const SPREAD_PER_POINT = 25; // Elo difference per point of spread.
  const ADMIN_PASSWORD = "changeme"; // TODO: change this to your secret

  const STORAGE_KEY = "suicide_squaf_elo_app_v1";

  // ======= STATE =======
  let state = {
    players: [], // {id, name}
    games: []    // {id, dateISO, player1Id, player2Id, score1, score2}
  };

  let adminMode = false;
  let editingGameId = null;

  // ======= UTILITIES =======
  function uuid() {
    return "xxxx-4xxx-yxxx".replace(/[xy]/g, c => {
      const r = (Math.random() * 16) | 0;
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  function saveState() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function loadState() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    try {
      const parsed = JSON.parse(raw);
      if (parsed && Array.isArray(parsed.players) && Array.isArray(parsed.games)) {
        state = parsed;
      }
    } catch (e) {
      console.error("Failed to parse saved state", e);
    }
  }

  function formatDate(iso) {
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return iso;
    return d.toLocaleString(undefined, {
      month: "short",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    });
  }

  function halfPointRound(num) {
    return Math.round(num * 2) / 2;
  }

  // Margin-of-victory multiplier (sports Elo style)
  function marginMultiplier(margin, ratingDiff) {
    if (margin <= 0) return 1;
    const ln = Math.log(1 + margin);
    const denom = 2.2 + 0.001 * Math.abs(ratingDiff);
    return 1 + (2.2 * ln) / denom;
  }

  // ======= ELO ENGINE =======
  function computeElo() {
    const ratings = new Map();
    const stats = new Map(); // playerId -> {games, wins, losses}
    state.players.forEach(p => {
      ratings.set(p.id, START_ELO);
      stats.set(p.id, { games: 0, wins: 0, losses: 0 });
    });

    const gamesSorted = [...state.games].sort(
      (a, b) => new Date(a.dateISO) - new Date(b.dateISO)
    );

    const enrichedGames = [];

    for (const game of gamesSorted) {
      const { player1Id, player2Id, score1, score2 } = game;

      const r1before = ratings.get(player1Id) ?? START_ELO;
      const r2before = ratings.get(player2Id) ?? START_ELO;

      const result1 =
        score1 > score2 ? 1 : score1 < score2 ? 0 : 0.5;
      const result2 = 1 - result1;

      const expected1 = 1 / (1 + Math.pow(10, (r2before - r1before) / 400));
      const expected2 = 1 / (1 + Math.pow(10, (r1before - r2before) / 400));

      const margin = Math.abs(score1 - score2);
      const g = marginMultiplier(margin, r1before - r2before);

      const r1after = r1before + K_FACTOR * g * (result1 - expected1);
      const r2after = r2before + K_FACTOR * g * (result2 - expected2);

      ratings.set(player1Id, r1after);
      ratings.set(player2Id, r2after);

      const s1 = stats.get(player1Id) || { games: 0, wins: 0, losses: 0 };
      const s2 = stats.get(player2Id) || { games: 0, wins: 0, losses: 0 };
      s1.games += 1;
      s2.games += 1;
      if (result1 === 1) {
        s1.wins += 1;
        s2.losses += 1;
      } else if (result1 === 0) {
        s1.losses += 1;
        s2.wins += 1;
      }
      stats.set(player1Id, s1);
      stats.set(player2Id, s2);

      enrichedGames.push({
        ...game,
        r1before,
        r2before,
        r1after,
        r2after,
        expected1,
        expected2,
        result1,
        result2,
        margin
      });
    }

    return { ratings, enrichedGames, stats };
  }

  function computeHeadToHead(enrichedGames) {
    const h2h = {};

    function ensureCell(a, b) {
      if (!h2h[a]) h2h[a] = {};
      if (!h2h[a][b]) h2h[a][b] = { w: 0, l: 0 };
      return h2h[a][b];
    }

    for (const g of enrichedGames) {
      const { player1Id, player2Id, score1, score2 } = g;
      if (score1 === score2) continue;

      const p1wins = score1 > score2;
      const cell1 = ensureCell(player1Id, player2Id);
      const cell2 = ensureCell(player2Id, player1Id);

      if (p1wins) {
        cell1.w += 1;
        cell2.l += 1;
      } else {
        cell1.l += 1;
        cell2.w += 1;
      }
    }

    return h2h;
  }

  // ======= DOM RENDERING =======
  const els = {
    playerCountLabel: document.getElementById("player-count-label"),
    gameCountLabel: document.getElementById("game-count-label"),
    lastUpdatedLabel: document.getElementById("last-updated-label"),
    playersTableBody: document.querySelector("#playersTable tbody"),
    gamesTableBody: document.querySelector("#gamesTable tbody"),
    h2hHead: document.querySelector("#h2hTable thead"),
    h2hBody: document.querySelector("#h2hTable tbody"),
    newPlayerName: document.getElementById("newPlayerName"),
    addPlayerBtn: document.getElementById("addPlayerBtn"),
    resetDataBtn: document.getElementById("resetDataBtn"),
    gameForm: document.getElementById("gameForm"),
    player1Select: document.getElementById("player1"),
    player2Select: document.getElementById("player2"),
    score1Input: document.getElementById("score1"),
    score2Input: document.getElementById("score2"),
    preGameInfo: document.getElementById("preGameInfo"),
    adminLoginBtn: document.getElementById("adminLoginBtn"),
    adminStatus: document.getElementById("adminStatus"),
    saveGameBtn: document.getElementById("saveGameBtn")
  };

  function rebuildPlayerSelects() {
    const selects = [
      els.player1Select,
      els.player2Select
    ];
    const placeholderOption = (label) =>
      `<option value="">${label}</option>`;

    selects.forEach((sel, idx) => {
      const label =
        idx === 0 ? "Select player 1" :
        "Select player 2";
      sel.innerHTML = placeholderOption(label);
      state.players.forEach((p) => {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name;
        sel.appendChild(opt);
      });
    });
  }

  function renderAdminStatus() {
    if (adminMode) {
      els.adminStatus.innerHTML = `<span>Admin mode ON</span>`;
    } else {
      els.adminStatus.innerHTML = `<span class="muted">Admin mode OFF</span>`;
    }
  }

  function render() {
    const { ratings, enrichedGames, stats } = computeElo();
    const h2h = computeHeadToHead(enrichedGames);

    // Meta labels
    els.playerCountLabel.textContent = `${state.players.length} player${state.players.length === 1 ? "" : "s"}`;
    els.gameCountLabel.textContent = `${state.games.length} game${state.games.length === 1 ? "" : "s"} recorded`;
    if (state.games.length > 0) {
      const newest = state.games.reduce((a, b) =>
        new Date(a.dateISO) > new Date(b.dateISO) ? a : b
      );
      els.lastUpdatedLabel.textContent = `Last entry: ${formatDate(newest.dateISO)}`;
    } else {
      els.lastUpdatedLabel.textContent = "No games yet";
    }

    // Players table – sorted by Elo, then H2H, then alpha
    els.playersTableBody.innerHTML = "";
    const playersSorted = [...state.players].sort((a, b) => {
      const ra = ratings.get(a.id) ?? START_ELO;
      const rb = ratings.get(b.id) ?? START_ELO;
      if (rb !== ra) {
        return rb - ra; // higher Elo first
      }

      // Elo tie: look at head-to-head between a and b
      const cellAB = h2h[a.id]?.[b.id];
      const cellBA = h2h[b.id]?.[a.id];
      if (cellAB || cellBA) {
        const netAB = (cellAB?.w || 0) - (cellAB?.l || 0);
        const netBA = (cellBA?.w || 0) - (cellBA?.l || 0);
        const diff = netAB - netBA;
        if (diff !== 0) {
          return diff > 0 ? -1 : 1; // more net wins vs the other = higher
        }
      }

      // Still tied: alphabetical
      return a.name.localeCompare(b.name);
    });

    playersSorted.forEach((p) => {
      const tr = document.createElement("tr");
      const r = ratings.get(p.id) ?? START_ELO;
      const s = stats.get(p.id) || { games: 0, wins: 0, losses: 0 };
      const wl = `${s.wins}-${s.losses}`;

      tr.innerHTML = `
        <td>${p.name}</td>
        <td class="text-right">
          <span class="link-like" data-highlight-player="${p.id}">
            ${Math.round(r)}
          </span>
        </td>
        <td class="text-right">${s.games}</td>
        <td class="text-right">${wl}</td>
      `;
      els.playersTableBody.appendChild(tr);
    });

    // Games table (newest first)
    els.gamesTableBody.innerHTML = "";
    const gamesNewestFirst = [...enrichedGames].sort(
      (a, b) => new Date(b.dateISO) - new Date(a.dateISO)
    );

    for (const g of gamesNewestFirst) {
      const p1 = state.players.find(p => p.id === g.player1Id);
      const p2 = state.players.find(p => p.id === g.player2Id);
      const name1 = p1 ? p1.name : "Player 1";
      const name2 = p2 ? p2.name : "Player 2";

      const winnerTag1 =
        g.score1 > g.score2
          ? `<span class="tag">Win</span>`
          : g.score1 < g.score2
          ? `<span class="tag loss">Loss</span>`
          : `<span class="badge-soft">Tie</span>`;

      const winnerTag2 =
        g.score2 > g.score1
          ? `<span class="tag">Win</span>`
          : g.score2 < g.score1
          ? `<span class="tag loss">Loss</span>`
          : `<span class="badge-soft">Tie</span>`;

      const delta1 = g.r1after - g.r1before;
      const delta2 = g.r2after - g.r2before;

      const deltaSpan1 = `<span class="${delta1 >= 0 ? "elo-up" : "elo-down"}">(${delta1 >= 0 ? "+" : ""}${delta1.toFixed(1)})</span>`;
      const deltaSpan2 = `<span class="${delta2 >= 0 ? "elo-up" : "elo-down"}">(${delta2 >= 0 ? "+" : ""}${delta2.toFixed(1)})</span>`;

      const adminCells = adminMode
        ? `<button class="secondary btn-small" data-edit-game="${g.id}">Edit</button>
           <button class="secondary btn-small danger" data-delete-game="${g.id}">Delete</button>`
        : `<span class="muted small">Admin only</span>`;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${formatDate(g.dateISO)}</td>
        <td>${name1} vs ${name2}</td>
        <td>${g.score1} – ${g.score2}</td>
        <td>
          <div>${name1}: ${winnerTag1}</div>
          <div>${name2}: ${winnerTag2}</div>
        </td>
        <td>
          <div><span class="muted">Before:</span> ${Math.round(g.r1before)}</div>
          <div><span class="muted">After:</span> ${Math.round(g.r1after)} ${deltaSpan1}</div>
        </td>
        <td>
          <div><span class="muted">Before:</span> ${Math.round(g.r2before)}</div>
          <div><span class="muted">After:</span> ${Math.round(g.r2after)} ${deltaSpan2}</div>
        </td>
        <td class="text-right">
          ${adminCells}
        </td>
      `;
      els.gamesTableBody.appendChild(tr);
    }

    // Head-to-head matrix (alphabetical)
    renderHeadToHead(h2h);

    // Rebuild selects (players may have changed)
    rebuildPlayerSelects();

    // Update pre-game line preview
    updatePreGameInfo();
    renderAdminStatus();
  }

  function renderHeadToHead(h2h) {
    els.h2hHead.innerHTML = "";
    els.h2hBody.innerHTML = "";

    if (state.players.length === 0) {
      els.h2hBody.innerHTML = `<tr><td class="muted">Add players to see head-to-head records.</td></tr>`;
      return;
    }

    // Alphabetical order for H2H
    const playersSorted = [...state.players].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    const headerRow = document.createElement("tr");
    headerRow.innerHTML = `<th>Player</th>` +
      playersSorted.map(p => `<th class="text-center">${p.name}</th>`).join("");
    els.h2hHead.appendChild(headerRow);

    playersSorted.forEach(rowP => {
      const tr = document.createElement("tr");
      let html = `<td>${rowP.name}</td>`;
      playersSorted.forEach(colP => {
        if (rowP.id === colP.id) {
          html += `<td class="text-center muted">—</td>`;
        } else {
          const cell = h2h[rowP.id]?.[colP.id];
          if (!cell) {
            html += `<td class="text-center muted">0–0</td>`;
          } else {
            html += `<td class="text-center">${cell.w}&ndash;${cell.l}</td>`;
          }
        }
      });
      tr.innerHTML = html;
      els.h2hBody.appendChild(tr);
    });
  }

  // ======= PRE-GAME PREVIEW (line lives here) =======
  function updatePreGameInfo() {
    const p1Id = els.player1Select.value;
    const p2Id = els.player2Select.value;
    const s1 = parseInt(els.score1Input.value, 10);
    const s2 = parseInt(els.score2Input.value, 10);

    const { ratings } = computeElo();
    const r1 = ratings.get(p1Id) ?? START_ELO;
    const r2 = ratings.get(p2Id) ?? START_ELO;

    if (!p1Id || !p2Id || p1Id === p2Id) {
      els.preGameInfo.innerHTML = `<span>Choose two different players to see their current Elo, line, and projected Elo change.</span>`;
      return;
    }

    const player1 = state.players.find(p => p.id === p1Id)?.name || "Player 1";
    const player2 = state.players.find(p => p.id === p2Id)?.name || "Player 2";

    const diff = r1 - r2;
    const rawSpread = diff / SPREAD_PER_POINT;
    const spread = halfPointRound(rawSpread);

    let lineText;
    if (spread > 0) {
      lineText = `${player1} -${Math.abs(spread)} vs ${player2}`;
    } else if (spread < 0) {
      lineText = `${player2} -${Math.abs(spread)} vs ${player1}`;
    } else {
      lineText = "Pick'em";
    }

    let scenarioText = "";
    if (!Number.isNaN(s1) && !Number.isNaN(s2)) {
      const result1 =
        s1 > s2 ? 1 : s1 < s2 ? 0 : 0.5;
      const expected1 = 1 / (1 + Math.pow(10, (r2 - r1) / 400));
      const margin = Math.abs(s1 - s2);
      const g = marginMultiplier(margin, r1 - r2);
      const r1After = r1 + K_FACTOR * g * (result1 - expected1);
      const delta = r1After - r1;
      scenarioText =
        `${player1} would move to ${Math.round(r1After)} (${delta >= 0 ? "+" : ""}${delta.toFixed(1)}) Elo with that scoreline.`;
    }

    els.preGameInfo.innerHTML = `
      <span>
        <strong>${player1}</strong> Elo: ${Math.round(r1)} · 
        <strong>${player2}</strong> Elo: ${Math.round(r2)}
      </span>
      <span>
        Line: <span class="spread-chip">${lineText}</span>
      </span>
      ${scenarioText ? `<span>${scenarioText}</span>` : ""}
    `;
  }

  // ======= EVENT HANDLERS =======
  function handleAddPlayer() {
    const name = els.newPlayerName.value.trim();
    if (!name) return;
    if (state.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
      alert("That name is already in use. Player names must be unique.");
      return;
    }
    const id = uuid();
    state.players.push({ id, name });
    els.newPlayerName.value = "";
    saveState();
    render();
  }

  function handleResetData() {
    if (!adminMode) {
      alert("Admin mode is OFF. Use Admin Login first.");
      return;
    }
    if (!confirm("This will delete ALL players and games from this browser. Are you sure?")) {
      return;
    }
    state = { players: [], games: [] };
    editingGameId = null;
    saveState();
    render();
  }

  function handleGameSubmit(event) {
    event.preventDefault();
    const player1Id = els.player1Select.value;
    const player2Id = els.player2Select.value;
    if (!player1Id || !player2Id || player1Id === player2Id) {
      alert("Please select two different players.");
      return;
    }

    const score1 = parseInt(els.score1Input.value, 10);
    const score2 = parseInt(els.score2Input.value, 10);
    if (Number.isNaN(score1) || Number.isNaN(score2)) {
      alert("Please enter numeric scores for both players.");
      return;
    }

    if (editingGameId) {
      const idx = state.games.findIndex(g => g.id === editingGameId);
      if (idx !== -1) {
        state.games[idx].player1Id = player1Id;
        state.games[idx].player2Id = player2Id;
        state.games[idx].score1 = score1;
        state.games[idx].score2 = score2;
      }
      editingGameId = null;
      els.saveGameBtn.textContent = "Save Game";
    } else {
      const newGame = {
        id: uuid(),
        dateISO: new Date().toISOString(),
        player1Id,
        player2Id,
        score1,
        score2
      };
      state.games.push(newGame);
    }

    saveState();
    els.score1Input.value = "";
    els.score2Input.value = "";
    render();
  }

  function handlePlayersTableClick(event) {
    const eloHighlight = event.target.closest("[data-highlight-player]");

    if (eloHighlight) {
      const id = eloHighlight.getAttribute("data-highlight-player");
      highlightPlayerGames(id);
    }
  }

  function handleGamesTableClick(event) {
    const editBtn = event.target.closest("button[data-edit-game]");
    const deleteBtn = event.target.closest("button[data-delete-game]");

    if (editBtn) {
      if (!adminMode) {
        alert("Admin mode is OFF. Use Admin Login to edit games.");
        return;
      }
      const id = editBtn.getAttribute("data-edit-game");
      startEditingGame(id);
      return;
    }

    if (deleteBtn) {
      if (!adminMode) {
        alert("Admin mode is OFF. Use Admin Login to delete games.");
        return;
      }
      const id = deleteBtn.getAttribute("data-delete-game");
      deleteGame(id);
      return;
    }
  }

  function highlightPlayerGames(playerId) {
    const { enrichedGames } = computeElo();
    const gamesNewestFirst = [...enrichedGames].sort(
      (a, b) => new Date(b.dateISO) - new Date(a.dateISO)
    );

    const rows = els.gamesTableBody.querySelectorAll("tr");
    rows.forEach(row => row.style.outline = "none");

    rows.forEach((row, idx) => {
      const game = gamesNewestFirst[idx];
      if (game && (game.player1Id === playerId || game.player2Id === playerId)) {
        row.style.outline = "1px solid rgba(56, 189, 248, 0.9)";
      }
    });
  }

  function startEditingGame(gameId) {
    const game = state.games.find(g => g.id === gameId);
    if (!game) return;
    editingGameId = gameId;
    els.player1Select.value = game.player1Id;
    els.player2Select.value = game.player2Id;
    els.score1Input.value = game.score1;
    els.score2Input.value = game.score2;
    els.saveGameBtn.textContent = "Update Game";
    updatePreGameInfo();
    window.scrollTo({ top: 0, behavior: "smooth" });
  }

  function deleteGame(gameId) {
    if (!confirm("Delete this game? Elo ratings will be recalculated without it.")) {
      return;
    }
    state.games = state.games.filter(g => g.id !== gameId);
    if (editingGameId === gameId) {
      editingGameId = null;
      els.saveGameBtn.textContent = "Save Game";
    }
    saveState();
    render();
  }

  function handleAdminLogin() {
    if (adminMode) {
      if (confirm("Turn OFF admin mode?")) {
        adminMode = false;
        editingGameId = null;
        els.saveGameBtn.textContent = "Save Game";
        render();
      }
      return;
    }

    const pwd = prompt("Enter admin password:");
    if (pwd === null) return;
    if (pwd === ADMIN_PASSWORD) {
      adminMode = true;
      render();
    } else {
      alert("Incorrect password.");
    }
  }

  function init() {
    loadState();
    render();

    els.addPlayerBtn.addEventListener("click", handleAddPlayer);
    els.newPlayerName.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleAddPlayer();
      }
    });

    els.resetDataBtn.addEventListener("click", handleResetData);
    els.gameForm.addEventListener("submit", handleGameSubmit);

    els.playersTableBody.addEventListener("click", handlePlayersTableClick);
    els.gamesTableBody.addEventListener("click", handleGamesTableClick);

    [els.player1Select, els.player2Select, els.score1Input, els.score2Input].forEach(el => {
      el.addEventListener("input", updatePreGameInfo);
      el.addEventListener("change", updatePreGameInfo);
    });

    els.adminLoginBtn.addEventListener("click", handleAdminLogin);
  }

  // Call init directly so it runs immediately on load
  init();
</script>
</body>
</html>
